using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using EnvDTE;
using MadsKristensen.EditorExtensions.Commands;
using MadsKristensen.EditorExtensions.Compilers;
using Microsoft.Html.Editor;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;

namespace MadsKristensen.EditorExtensions.TypeScript
{
    ///<summary>An <see cref="ICompilationNotifier"/> that watches for TypeScript files generated by VS' built-in async compiler.</summary>
    internal class TypeScriptCompilationNotifier : ICompilationNotifier
    {
        private readonly ICollection<IFileSaveListener> _listeners;
        private readonly FileSystemWatcher _watcher;
        public ITextDocument Document { get; private set; }
        public string SourceFilePath { get { return Document.FilePath; } }
        public string TargetFilePath { get { return GetOutputFileName(); } }

        private bool _isReady;

        private string _outputFile;

        private string GetOutputFileName()
        {
            if (!string.IsNullOrEmpty(_outputFile))
                return _outputFile;

            IVsSolution solution = WebEssentialsPackage.GetGlobalService<IVsSolution>(typeof(SVsSolution));
            Project project = ProjectHelpers.GetProject(SourceFilePath);
            IVsHierarchy hierarchy = null;

            if (project != null && solution.GetProjectOfUniqueName(project.UniqueName, out hierarchy) != VSConstants.S_OK)
                return string.Empty;

            IVsBuildPropertyStorage buildPropertyStorage = hierarchy as IVsBuildPropertyStorage;

            if (buildPropertyStorage == null)
            {
                _outputFile = Path.ChangeExtension(SourceFilePath, ".js");
            }
            else
            {
                string outputFile, outputDir;
                string config = WebEssentialsPackage.DTE.Solution.SolutionBuild.ActiveConfiguration.Name;
                int resultFile = buildPropertyStorage.GetPropertyValue("TypeScriptOutFile", config, (uint)_PersistStorageType.PST_PROJECT_FILE, out outputFile);
                int resultDir = buildPropertyStorage.GetPropertyValue("TypeScriptOutDir", config, (uint)_PersistStorageType.PST_PROJECT_FILE, out outputDir);

                if (!string.IsNullOrEmpty(outputFile) && resultFile == VSConstants.S_OK)
                {
                    _outputFile = Path.Combine(ProjectHelpers.GetRootFolder(project), outputFile);
                }
                else if (!string.IsNullOrEmpty(outputDir) && resultDir == VSConstants.S_OK)
                {
                    string dir = Path.Combine(ProjectHelpers.GetRootFolder(project), outputDir);
                    string file = Path.ChangeExtension(Path.GetFileName(SourceFilePath), ".js");
                    _outputFile = Path.Combine(dir, file);
                }
            }

            if (string.IsNullOrEmpty(_outputFile))
                _outputFile = Path.ChangeExtension(SourceFilePath, ".js");

            return _outputFile;
        }

        public TypeScriptCompilationNotifier(ITextDocument doc)
        {
            Document = doc;
            Document.FileActionOccurred += Document_FileActionOccurred;

            _listeners = Mef.GetAllImports<IFileSaveListener>(ContentTypeManager.GetContentType("JavaScript"));

            string dir = Path.GetDirectoryName(TargetFilePath);

            if (!Directory.Exists(dir))
                return;

            _watcher = new FileSystemWatcher(dir);
            _watcher.Filter = Path.GetFileName(TargetFilePath);
            _watcher.EnableRaisingEvents = true;
            _watcher.Created += FileTouched;
            _watcher.Changed += FileTouched;
        }

        private void Document_FileActionOccurred(object sender, TextDocumentFileActionEventArgs e)
        {
            if (e.FileActionType == FileActionTypes.ContentSavedToDisk)
            {
                FileTouched(sender, null);
                return;
            }

            if (e.FileActionType != FileActionTypes.DocumentRenamed)
                return;

            _watcher.Path = Path.GetDirectoryName(TargetFilePath);
            _watcher.Filter = Path.GetFileName(TargetFilePath);
        }


        ///<summary>Releases all resources used by the EditorCompilerInvoker.</summary>
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        ///<summary>Releases the unmanaged resources used by the EditorCompilerInvoker and optionally releases the managed resources.</summary>
        ///<param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Document.FileActionOccurred -= Document_FileActionOccurred;
                _watcher.Created -= FileTouched;
                _watcher.Changed -= FileTouched;
                _watcher.Dispose();
            }
        }

        ///<summary>Occurs when the file has been compiled (on both success and failure).</summary>
        public event EventHandler<CompilerResultEventArgs> CompilationReady;

        ///<summary>Raises the CompilationReady event.</summary>
        ///<param name="e">A CompilerResultEventArgs object that provides the event data.</param>
        protected virtual void OnCompilationReady(CompilerResultEventArgs e)
        {
            if (CompilationReady != null)
                CompilationReady(this, e);
        }

        private async void FileTouched(object sender, FileSystemEventArgs e)
        {
            // The check for _isReady is in place to deal with the issue where
            // FileSystemWatcher fires twice per file change.
            if (!_isReady)
            {
                _isReady = true;
                return;
            }

            if (File.Exists(TargetFilePath))
            {
                RaiseReady().DoNotWait("reading " + TargetFilePath + "file");

                foreach (var listener in _listeners)
                    await listener.FileSaved(ContentTypeManager.GetContentType("JavaScript"), TargetFilePath, false, false);
            }

            _isReady = false;
        }

        public async void RequestCompilationResult(bool cached)
        {
            if (File.Exists(TargetFilePath))
                RaiseReady().DoNotWait("reading " + TargetFilePath + "file");
            else
                OnCompilationReady(new CompilerResultEventArgs(
                         await CompilerResultFactory.GenerateResult(
                                  sourceFileName: SourceFilePath,
                                  targetFileName: null,
                                  isSuccess: true,   // HACK: Set IsSuccess to true to force margin to display result
                                  result: "// Not compiled to disk yet",
                                  errors: null
                              )));
        }

        private async Task RaiseReady()
        {
            OnCompilationReady(new CompilerResultEventArgs(
                     await CompilerResultFactory.GenerateResult(
                              sourceFileName: SourceFilePath,
                              targetFileName: TargetFilePath,
                              isSuccess: true,
                              result: await FileHelpers.ReadAllTextRetry(TargetFilePath),
                              errors: null
                          )));
        }
    }
}